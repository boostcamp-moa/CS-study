## 1. 데드락의 정의

- 동시 프로그램(concurrent program)의 상태 중 하나로, 하나 이상의 프로세스가 영원히 발생할 수 없는 이벤트를 기다리고 있는 교착 상태를 의미한다. 
- 교착 상태에 있는 프로세스는 영원히 blocked된다. 즉, 더이상 진행되지 않는다.

<br>

## 2. 데드락의 예시

concurrent한 프로그램에서 프로세스 P1과 프로세스 P2가 있다고 가정하자. 프로세스 P1과 P2는 병렬적으로 돌아갈 것이며, 두 프로세스 모두 자원 A와 자원 B를 활용하는 로직을 수행해야 한다.

- P1이 수행해야 하는 명령어는 다음과 같다.

```
mutex_lock(A); // a1
mutex_lock(B); // a2
...
mutex_unlock(B);
mutex_unlock(A);
```

* P2가 수행해야 하는 명령어는 다음과 같다.

```
mutex_lock(B); // b1
mutex_lock(A); // b2
...
mutex_unlock(A);
mutex_unlock(B);
```

만약 두 개의 프로세스가 수행한 명령어의 순서가 a1, b1, b2, a2였다면 어떻게 될까?

a1. A라는 자원이 P1로부터 lock된다.

b1. B라는 자원이 P2로부터 lock된다.

b2. A라는 자원이 P2로부터 lock되어야 한다. 하지만, 이미 P1로부터 자원 A가 lock되어 있어서, lock을 건 P1이 자원 A에 대한 lock을 풀 때까지 기다린다. 즉, 프로세스 P2는 blocked된다.

a2. B라는 자원이 P1로부터 lock되어야 한다. 하지만, 이미 P2로부터 자원 B가 lock되어 있어서, lock을 건 P2가 자원 B에 대한 lock을 풀 때까지 기다린다. 하지만 P2는 이미 blocked되어 더이상의 로직을 수행하지 못하게 되었고, 영원히 자원 B에 대해 unlock할 수 없게 되었다. 결국, 프로세스 P1 또한 영원히 blocked된다.



비슷한 예시로, 어떠한 관계도 없는 독립적인 두 개의 프로세스가 동시에 두 개의 파일에 접근하게 된다면 마찬가지로 데드락이 발생할 위험이 있다.

<br>

## 3. 식사하는 철학자들 문제 (Dining Philosopher’s Problem)

![](https://thewiki.ewr1.vultrobjects.com/data/5468655f64696e696e675f7068696c6f736f70686572732e706e67.png)



대표적인 데드락 관련 문제로 많이 언급되는 것이 '식사하는 철학자들 문제'이다.

1. 다수의 철학자들이 원형 탁자에 앉아 있다.
2. 철학자들은 각자의 스파게티 그릇을 가지고 있다.
3. 모든 철학자는 `생각`과 `식사`를 무한히 반복한다.
4. 각 그릇들 사이에는 하나의 포크가 있다.
5. 철학자가 `식사`를 하고 싶을 때, 반드시 양쪽의 포크를 모두 사용해야 한다.
6. `식사`를 하고 싶은데 다른 철학자 혹은 철학자들이 자신의 양쪽 포크 중 하나 이상을 사용하고 있을 경우, 기다린다.

위 로직을 소스코드로 구현하면 각자의 철학자는 다음과 같은 로직을 수행해야 한다.

> A Philosopher process 

```
while(1) {
	think_for_a_while();
	mutex_lock(left_fork);
	mutex_lock(right_fork);
	eat();
	mutex_unlock(left_fork);
	mutex_unlock(right_fork);
}
```

모든 철학자가 생각을 한 후, 왼쪽 포크를 들었다. 이후 오른쪽 포크를 들려고 했지만, 이미 각 철학자가 왼쪽의 포크를 들어버린 이상 본인의 오른쪽 포크는 남아있지 않는다. 그렇게 되면 모든 철학자는 eat()을 하지 못하게 되며 영원히  block된 상태에 빠지게 된다. 이것을 `기아 상태`라고 표현한다.

이러한 문제는 테이블이 원형 테이블의 순환 대기 혹은 환형 대기(circular wait) 조건 때문에 발생하게 된다.

해결 방법은 [위키백과](https://ko.wikipedia.org/wiki/%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94_%EC%B2%A0%ED%95%99%EC%9E%90%EB%93%A4_%EB%AC%B8%EC%A0%9C)에도 간략히 나와 있고, 그 외의 방법으로 circular wait를 해결하는 방식도 있다.

<br>

## 4. 데드락 발생의 4가지 조건

아래의 네 가지 조건을 모두 만족하면 데드락이 발생할 수도 있다. 하지만 발생하지 않을 수도 있다.

반대로, 아래 네 가지 조건 중 하나라도 만족하지 않으면 데드락은 절대 발생하지 않는다.

<br>

##### 1. 상호 배제 (Mutual exclusion)

매 순간 하나의 프로세스만이 자원을 사용할 수 있다. 즉, 자원은 상호배타적으로 이용되어야 한다. 

##### 2. 점유 대기 (Hold and wait)

자원을 가진 프로세스가 다른 자원을 기다릴 때 점유한 자원을 놓지 않고 계속 가지고 있는다.

##### 3. 비선점 (Non-preemption)

프로세스는 자원을 스스로 내어놓을 뿐, 강제로 빼앗기지 않는다.

##### 4. 순환 대기(Circular wait)

자원을 기다리는 프로세스 간에 사이클이 형성되어야 한다.

- 프로세스 P0, P1, ..., Pn이 있을 때
  - P0은 P1이 가진 자원을 기다림
  - P1은 P2가 가진 자원을 기다림
  - ...
  - Pn-1은 Pn이 가진 자원을 기다림
  - Pn은 P0이 가진 자원을 기다림

<br>

## 5. 데드락의 처리 방법

### 1. 예방 (Prevention)

자원 할당 시 데드락의 4가지 필요 조건 중 어느 하나가 만족되지 않도록 한다. 

- **상호 배제 부정**

  - 여러 프로세스가 자원을 공유하여 사용

  - 공유해서는 안 되는 자원의 경우 반드시 성립해야 하는 문제가 존재

    ex) 프린터, 쓰기를 위한 파일 락 등

- **점유 대기 부정**
  - 한 프로세스가 실행되기 전 모든 자원을 할당
  - 사용하지 않는 자원까지 과다하게 점유하게 되므로 아래와 같은 문제 발생
    - 실제 자원의 이용률 저하 -> 기아 상태(Starvation) 우려
    - 프로세스가 요구하는 자원을 파악하는 비용
    - 자원에 대한 상태를 저장 및 복원하기 위한 비용

- **비선점 부정**

  - 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고, 요구한 자원을 사용하기 위해 기다리게 함

    ```
    1. P1: 자원 A를 lock
    2. P2: 자원 B를 lock
    3. P2: 자원 A를 lock
    	-> 자원 A는 P1이 점유하고 있으므로 P1의 점유가 끝날 때까지 block되어야 한다. 이때, 다른 프로세스 중 P2가 점유하고 있는 자원 B를 사용하고자 할 수 있으니 자원을 반납해놓는다.
    4. P3: 자원 B를 lock
    ...
    5. P1: 자원 A를 unlock
    6. P2: 자원 A를 lock (5번 동작 덕분에 가능해졌다)
    	-> 하지만 P2가 로직에서 사용해야 하는 자원 B를 P3가 점유하고 있으므로 또 대기
    7. P3: 자원 B를 unlock
    8. P2: 자원 B를 lock
    	-> 드디어 P2가 요구한 자원을 모두 사용할 수 있게 되었으므로 P2의 로직 시작
    ```

- **순환 대기 부정**

  - 모든 자원 유형에 할당 순서를 정하여 정해진 순서대로만 자원을 할당
    - 예를 들어 순서가 3인 자원 Ri를 보유 중인 프로세스가 순서가 1인 자원 Rj를 할당받기 위해서는 우선 Ri를 release해야 함
  - 점유 대기 부정보다 비용이 적음

<br>

### 2. 회피 (Avoidance)

- 자원 요청에 대한 부가적인 정보를 활용해서 시스템을 불안전하게 만드는 요소가 없다면(=데드락의 가능성이 없는 경우라면) 자원을 할당해준다.
- 핵심 개념
  - `safe state`
    - 시스템 내의 프로세스들에 대한 safe seqeunce가 존재하는 상태
    - 하나의 safe seqeunce라도 존재한다면 safe state라고 판단
    - safe seqeunce가 존재하지 않는 상태는 unsafe state라고 판단하며, unsafe state는 데드락의 필요조건임. 하지만 필요조건일 뿐, unsafe state라고 해서 무조건 데드락이 발생하진 않음.
  - `safe sequence`
    - 이전 프로세스가 수행을 마치고 반납한 자원과 현재 할당 가능한 자원을 이용해 현재 프로세스에게 할당이 가능한 프로세스의 자원 할당 순서
- 자원의 인스턴스가 하나일 경우, `자원 할당 그래프(Resource Allocation Graph)`를 활용하여 판단
- 자원의 인스턴스가 복수일 경우, `은행원 알고리즘(Banker's Algorithm)`을 활용하여 판단
- [참고](https://baked-corn.tistory.com/13?category=718232)

<br>

### 3. 탐지 및 회복 (Detection And Recovery)

데드락 발생을 허용하되, 그에 대한 탐지 루틴을 커널 자체에 두어 주기적으로 루틴을 실행하고 데드락이 발견될 시 회복하는 방법이다.

- **탐지**

  - 자원할당 그래프의 변형인 `Wait-for graph 알고리즘`을 활용하여 데드락을 탐지

- **회복**

  - 프로세스 종료 (Process termination)
    - 교착 상태의 프로세스를 모두 중지
    - 교착 상태가 제거될 때까지 하나씩 프로세스 중지

  - 자원 선점 방법 (Resource Preemption)
    - 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당 (해당 프로세스 일시정지 시킴)
    - 우선 순위가 낮은 프로세스나 수행 횟수 적은 프로세스 위주로 프로세스 자원 선점

<br>

### 4. 데드락 무시 (Deadlock Ignorance)

처리 방법이라고 하기에는 애매하지만, UNIX를 포함한 대부분의 OS가 채택하여 간략히 설명

- 데드락이 발생하지 않는다고 가정하고 시스템이 데드락을 책임지지 않음
- 데드락이 매우 드물게 발생하므로 데드락에 대한 조치 자체가 더 큰 오버헤드일 수 있다는 전제
- 만약 시스템에 데드락이 발생한 경우, 시스템이 비정상적으로 작동하는 것을 사람이 느낀 후 직접 프로세스를 죽이는 등의 방법으로 대처
- 개발자가 데드락이 발생하지 않도록 잘 짜는 수 밖에 없는 것이야...



---

레퍼런스

1. [[10] 운영체제 - Deadlock-2](https://baked-corn.tistory.com/13?category=718232)

2. [[운영체제] 교착상태 회피 - 은행원 알고리즘(Banker's Algorithm) 쉬운 예시, 안전상태, 불안전상태](https://jhnyang.tistory.com/102)

3. [KOCW - 반효경 교수님의 운영체제 수업](http://www.kocw.net/home/search/kemView.do?kemId=1046323)

