# 자료구조 정리

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F21BA9A3359719D420434DD" />

- 선형구조란 자료를 구성하는 데이터를 순차적으로 나열시킨 형태를 의미한다.
- 비선형구조란 하나의 자료 뒤에 여러개의 자료가 존재할 수 있는 것을 의미한다.

<br>

## 배열 (Array)

> index로 빠르게 값을 찾는 것이 가능하다.

- 특징
  - 배열은 데이터를 논리적 순서에 따라 순차적으로 데이터를 입력하며, 물리적 주소 또한 순차적이다.

- 장점
  - 인덱스를 가지고 있어서 원하는 데이터를 한번에 접근이 가능하기 때문에 `데이터 접근 속도`가 매우 빠르다. (`O(1)`)
  - 연속된 메모리 공간으로 이루어져 있어서 메모리 관리가 편하다.

- 단점
  - 배열은 데이터의 `삽입/삭제에는 취약`하다. 배열 특성상 데이터 삽입/삭제가 이루어지면 삽입/삭제가 이루어진 위치의 다음부터 모든 데이터의 위치를 shift해야 하기 때문에 비효율적이다.(`O(n)`)
  - 배열의 크기를 컴파일 이전에 정해주어야 한다. 따라서 컴파일 이후 배열의 크기를 변동 할 수 없다.
  - 크기가 고정되어있기 때문에 어떤 엘리먼트가 삭제되면, 삭제된 상태를 빈 공간으로 남겨두어야 한다. 따라서 메모리 낭비가 발생한다.

<br>

## 연결리스트 (Linked List)

> 데이터의 삽입 및 삭제가 빠르다.

- 특징
  - 연결리스트는 논리적 순서에 따라 데이터를 입력한다. 하지만 물리적 주소는 순차적이지 않음.
  - 인덱스를 가지고 있는 배열과는 달리 연결리스트는 인덱스 대신 현재 위치의 이전 및 다음 위치를 기억하고 있다.

- 장점
  - 데이터 삽입/삭제는 논리적 주소만 바꿔주면 되기 때문에 데이터 삽입/삭제는 용이하다.(`O(1)`)
  
- 단점
  - 한번에 데이터 접근이 가능하지 않고 연결되어 있는 링크를 따라가야만 접근이 가능하고, 배열에 비해 속도가 떨어진다. (`O(n)`)

- 시간 복잡도
  - Insertion
    - `O(1)` ( 특정 위치에 노드를 넣기만 하면 되기 때문에)
  - Deletion
    - `O(1)` ( 특정 위치에 있는 노드를 제거하기만 하면 되기 때문에)
  - Search
    - `O(n)` (n은 연결리스트의 길이를 의미하며, 마지막 노드를 찾으려면 연결리스트의 끝까지 모든 노드를 검색해서 찾아봐야 하기 때문에)

<br>

## 배열과 연결리스트의 비교

- 배열 사용
  - 저장할 데이터의 최대 개수가 정해져 있고 리스트의 중간에 데이터를 삽입, 삭제하는 작업이 많지 않은 경우
  - `index`를 이용한 빠른 검색이 필요한 경우

- 연결리스트 사용
  - 저장될 데이터의 개수가 정해져 있지 않고 리스트의 중간에 데이터를 삽입하거나 삭제하는 작업이 많은 경우
  - 삽입, 삭제에 비해 특정 위치의 데이터를 검색하는 작업이 많지 않은 경우

<br>

## 스택

> LIFO (Last In First Out, 후입선출) : 가장 나중에 들어온 것이 가장 먼저 나온다.
> 한 쪽 끝에서만 자료를 넣고 뺄 수 있다.

- 사용하는 경우
  - 함수의 콜스택
  - 재귀 알고리즘
  - 문자열 역순 출력
  - 연산자 후위표기법
  - 웹 브라우저 방문기록(뒤로가기)
  - 실행 취소
  - 수식의 괄호 검사

- 특징
  - 배열과 달리 스택은 상수 시간에 index번째 항목에 접근할 수 없다.
  - 하지만 스택에서 데이터를 추가하거나 삭제하는 연산은 상수 시간(`O(1)`)에 가능하다.
  - 배열처럼 원소들을 하나씩 옆으로 shift해줄 필요가 없다.

- 시간복잡도
  - Insertion
    - `O(1)` ( PUSH를 하여 값을 넣기만 하면 되기 때문에)
  - Deletion
    - `O(1)` ( POP을 하여 값을 빼기만 하면 되기 때문에)
  - Search
    - `O(n)`

<br>

## 큐

> FIFO (First In First Out, 선입선출) : 가장 먼저 들어온 것이 가장 먼저 나온다.
> 입력과 출력을 한 쪽 끝(front, rear)으로 제한

- 사용하는 경우
  - 버퍼
  - 입력된 것들을 처리하고 있지 못하는 상황
  - BFS

- 단점
  - 큐에 빈 메모리가 남아 있어도 꽉차있는 것으로 판단할 수 있다.

- 시간 복잡도
  - Insertion
    - `O(1)` ( ENQUEUE를 하여 값을 넣기만 하면 되기 때문에)
  - Deletion
    - `O(1)` ( DEQUEUE를 하여 값을 빼기만 하면 되기 때문에)
  - Search
    - `O(n)` (n은 큐의 사이즈를 의미하며 상황에 따라 달라집니다.)

<br>

### 원형 큐

> 논리적으로 배열의 처음과 끝이 연결되어 있는 것으로 간주한다.

- 특징
  - 공백, 포화를 구분하기 위해 항상 공간 하나를 비워둔다.

- 단점
  - 메모리 공간은 잘 활용하지만, 배열로 구현되어 있기 때문에 큐의 크기가 제한되어 있다.

<br>

### 연결리스트 큐

> 크기가 제한이 없고 삽입, 삭제가 편리하다.

- 특징
  - 삽입은 tail, 제거는 head로 하면서, 삽입/삭제를 스택처럼 `O(1)`에 가능하도록 구현이 가능하다.

<br>

## 우선순위 큐

> 가장 우선순위가 높은 데이터를 먼저 꺼내기 위해 고안된 자료구조이다.

- 들어간 순서에 상관없이 우선순위가 높은 데이터가 먼저 나온다.
- `힙`이라는 자료구조로 구현할 수 있다.

### 힙 기반으로 우선순위 큐를 구현하는 이유는?

![](https://gmlwjd9405.github.io/images/data-structure-heap/data-structure-heap-priorityqueue.png)

- 배열이나 연결리스트로 `우선순위 큐`를 구현할 경우
  - 삭제에는 `O(1)`
  - 삽입에는 `O(n)`

- `힙`으로 `우선순위 큐`를 구현할 경우
  > 높이가 하나 증가할 때마다 저장 가능한 자료의 개수는 2배 증가하며, 비교 연산 횟수는 1회 증가한다.
  - 삭제에는 `O(logn)`
  - 삽입에는 `O(logn)`

> 배열과 연결리스트로 기반의 구현이 `삭제`에서는 시간복잡도가 우위일지는 몰라도, 삽입에서는 힙 기반의 구현이 월등히 좋기 때문에 `힙` 기반으로 구현하는 것이다.

<br>

### 힙

> 힙은 `완전 이진 트리`이다.
> 모든 노드에 저장된 값(우선순위)들은 자식 노드들의 것보다(우선순위) 크거나 같다.
> 최소 힙이든, 최대 힙이든 루트 노드에는 우선순위가 높은 것이 자리잡는다.

- 최대힙
  ![](https://i.imgur.com/oP565GF.png)
  > 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리 
  - 루트 노드로 올라갈수록 저장된 값이 커지는 구조이다. 
  - 우선순위는 값이 큰 순서이다.

- 최소힙
  ![](https://i.imgur.com/lvXIQ8L.png)
  > 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리
  - 루트 노드로 올라갈수록 값이 작아지는 구조이다.
  - 우선순위는 값이 작은 순서이다.
  
  <br>

- 힙의 삽입
  1. 힙에 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 삽입
  2. 새로운 노드를 부모 노드들과 교환

- 힙의 삭제
  1. 최대 힙에서 최댓값은 루트 노드이므로 루트 녹드가 삭제된다.
  2. 삭제된 루트 노드에는 힙의 마지막 노드를 가져옴
  3. 힙을 재구성하는 과정을 거친다.

<br>

우선순위 큐는 힙으로 구현하는 것이 가장 좋고, 힙은 이진트리이기 때문에 배열 혹은 연결리스트로 구현할 수 있는데 `배열`구현이 좋다.

인덱스는 1부터 사용한다.
직관적이기도 하고, 다루기 용이해서이다.

<br>

## 해시

<img src="https://t1.daumcdn.net/cfile/tistory/25758F43580F530822" />

> 데이터를 효율적으로 관리하기 위해, 임의의 길이 데이터를 고정된 길이의 데이터로 매핑하는 것이다.
> 해시 함수를 구현하여 데이터 값을 해시 값으로 매핑한다.

```
Lee → 해싱함수 → 5
Kim → 해싱함수 → 3
Park → 해싱함수 → 2
...
Chun → 해싱함수 → 5 // Lee와 해싱값 충돌
```

데이터가 많아지면, 다른 데이터와 같은 해시 값으로 충돌나는 현상(collision)이 발생한다.

<br>

### 그래도 해시 테이블을 쓰는 이유는?

> 적은 자원으로 많은 데이터를 효율적으로 관리하기 위함이다.
> 하드디스크나, 클라우드에 존재하는 무한한 데이터들을 유한한 개수의 해시 값으로 매핑하면 작은 메모리로도 프로세스 관리가 가능해진다.

- 언제나 동일한 해시값 리턴
- index를 알면 빠른 데이터 검색이 가능해진다.
- 해시테이블의 시간복잡도 O(1) - (이진탐색트리는 O(logN))

<br>

- 시간 복잡도
  - Insertion
    - `O(1)`
  - Deletion
    - `O(1)`
  - Search
    - `O(1)`

- 한계점
  - 최대 키 값에 대해 알고 있어야 한다.
  - 최대 키 값이 작을 때 실용적으로 사용할 수 있다.
  - 키 값들이 골고루 분포되어있지 않다면 메모리 낭비가 심할 수밖에 없다.

<br>

### 적재율

> 적재율이란 해시 테이블의 크기 대비, 키의 개수를 말한다.
> 즉, 키의 개수를 K, 해시 테이블의 크기를 N 이라고 했을 때 적재율은 K/N 이다. Direct Address Table은 키 값을 인덱스로 사용하는 구조이기 때문에 적재율이 1 이하이며 적재율이 1 초과인 해시 테이블의 경우는 반드시 충돌이 발생하게 된다.

- 만약, 충돌이 발생하지 않다고 할 경우 해시 테이블의 탐색, 삽입, 삭제 연산은 모두 O(1) 에 수행되지만 충돌이 발생할 경우 탐색과 삭제 연산이 최악에 O(K) 만큼 걸리게 된다.

<br>

### 해시 테이블의 충돌 완화

#### 해시 테이블의 구조 개선

![](https://baeharam.github.io/images/data%20structure/hash/hash4.png)

- 체이닝 (Chaining)
  - 충돌 발생 시 이를 동일한 버킷에 저장한다.
  - 연결리스트 형태로 저장한다.
  - 시간복잡도
    - 삽입 : `O(1)`
    - 탐색, 삭제 : `O(K)`
  - 장점
    - 연결리스트만 사용하면 된다.
    - 해시테이블이 채워질수록, Lookup 성능 저하가 Linear하게 발생한다.

<br>

![](https://baeharam.github.io/images/data%20structure/hash/hash5.png)

- 오픈 어드레싱 (Open Addressing)
  - 충돌 발생 시 다음으로 비어있는 주소에 저장한다.
  - 삽입 : 계산한 해시 값에 대한 인덱스가 이미 차있는 경우 다음 인덱스로 이동하면서 비어있는 곳에 저장한다. 이렇게 비어있는 자리를 탐색하는 것을 탐사(Probing)라고 한다.
  - 탐색 : 계산한 해시 값에 대한 인덱스부터 검사하며 탐사를 해나가는데 이 때 “삭제” 표시가 있는 부분은 지나간다.
  - 삭제 : 탐색을 통해 해당 값을 찾고 삭제한 뒤 “삭제” 표시를 한다.
  - 장점
    - 체이닝처럼 포인터가 필요없고, 지정한 메모리 외에 추가적인 저장공간도 필요 없다.
    - 삽입, 삭제 시 오버헤드가 적다.
    - 저장할 데이터가 적을 때 더 유리하다.
  - 방식
    - 선형 탐사
    - 제곱 탐사
    - 이중 해싱

![](https://t1.daumcdn.net/cfile/tistory/25484F43581421980E)

<br>

#### 해시 함수 개선

- 나눗셈법
  - 미리 해시 테이블의 크기인 `N`을 아는 경우에 사용
  - 해시함수를 적용하고자 하는 값을 `N`으로 나눈 나머지를 해시값으로 사용하는 방법
  - `h(k) = k mod N`
  - `N`은 2의 제곱꼴을 사용하면 안 되고 소수를 사용하는 것이 좋다.
- 곱셈법
  - `h(k)=⌊N(kA mod 1)⌋`
  - `kA mod 1`의 의미는 `kA`의 소수점 이하 부분
  - 이를 `N`에 곱하므로 `0`부터 `N`사이의 값이 된다.
  - `N`이 어떤 값이더라도 잘 동작한다는 것이며 `A`를 잘 잡는 것이 중요하다.

<br>

## 트리

### 트리의 종류 1 : 이진 트리(binary tree)

> 이진트리는 자식노드를 최대 2개 가지는 트리를 말한다.

<br>

#### 완전 이진 트리(complete binary tree)

![](https://t1.daumcdn.net/cfile/tistory/996F8E405A74107713)

- 완전 이진 트리는 왼쪽 자식노드부터 채워지며 마지막 레벨을 제외하고는 모든 자식노드가 채워져있는 트리이다.

<br>

#### 포화 이진 트리(perfect binary tree)

![](https://t1.daumcdn.net/cfile/tistory/991914425A74646C24)

- 포화 이진 트리는 모든 리프노드가 똑같은 레벨에 있는 경우의 트리이다. 리프노드를 제외한 모든 노드는 2개의 자식노드를 가져야 한다.

<br>

#### 정 이진 트리(full binary tree)

![](https://t1.daumcdn.net/cfile/tistory/993E7F3D5A7411D00D)

- 정 이진 트리는 모든 노드가 0개 혹은 2개의 자식노드를 가지는 트리를 말한다. 포화 이진 트리의 하위종류이다.

<br>

#### 편향 이진 트리(skewed binary tree)

![](https://t1.daumcdn.net/cfile/tistory/99A211335A74121401)

- 편향 이진 트리는 말 그대로 노드들이 전부 한 방향으로 편향된 트리이다.

<br>

## 이진 탐색 트리 ([참고](https://mattlee.tistory.com/30))

> 이진탐색 + 연결리스트

- 이진탐색
  - 탐색에 소요되는 시간복잡도는 O(logN), but 삽입,삭제가 불가능
- 연결리스트
  - 삽입, 삭제의 시간복잡도는 O(1), but 탐색하는 시간복잡도가 O(N)

> 효율적인 탐색 능력을 가지고, 자료의 삽입, 삭제도 가능하게 만드려는 목적

- 특징
  - 각 노드의 자식이 2개 이하
  - 각 노드의 왼쪽 자식은 부모보다 작고, 오른쪽 자식은 부모보다 크다.
  - 중복된 노드가 없어야 한다.
  - 이진탐색트리의 순회는 '중위순회(inorder)' 방식 (왼쪽 - 루트 - 오른쪽)
  - 중위 순회로 정렬된 순서를 읽을 수 있다.
  - 모든 왼쪽 자식들 <= n < 모든 오른쪽 자식들 (모든 노드 n에 대해서 반드시 참)

<br>

### 중복이 없어야 하는 이유는?

- 검색 목적 자료구조인데, 굳이 중복이 많은 경우에 트리를 사용하여 검색 속도를 느리게 할 필요가 없다. (트리에 삽입하는 것보다, 노드에 count 값을 가지게 하여 처리하는 것이 훨씬 효율적)

<br>

### 시간복잡도 ([참고](https://eremo2002.tistory.com/24))

- 평균적인 경우 (균등 트리)
  - `Θ(log(N))`
- 최악의 경우 (편향 트리)
  - `O(N)`

하지만 이진탐색트리가 극단적인 구조를 가지게 될 경우, 한 쪽으로만 계속 늘어지는 구조를 가지게 된다.
이런 경우 시간복잡도는 `O(n)`이 된다.

이를 보완하기 위하여 [레드블랙트리](https://itstory.tk/entry/%EB%A0%88%EB%93%9C%EB%B8%94%EB%9E%99-%ED%8A%B8%EB%A6%ACRed-black-tree)를 사용한다.

<br>

## 트라이

> 문자열에서 검색을 빠르게 도와주는 자료구조

> 정수형에서 이진탐색트리를 이용하면 시간복잡도 O(logN)
> 하지만 문자열에서 적용했을 때, 문자열 최대 길이가 M이면 O(M\*logN)이 된다.
> 트라이를 활용하면? → O(M)으로 문자열 검색이 가능함

<br>

## B Tree & B+ Tree

> 이진 트리는 하나의 부모가 두 개의 자식밖에 가지질 못하고, 균형이 맞지 않으면 검색 효율이 선형검색 급으로 떨어진다. 하지만 이진 트리 구조의 간결함과 균형만 맞다면 검색, 삽입, 삭제 모두 O(logN)의 성능을 보이는 장점이 있기 때문에 계속 개선시키기 위한 노력이 이루어지고 있다.

<br>

## B Tree

> 데이터베이스, 파일 시스템에서 널리 사용되는 트리 자료구조의 일종이다.

> 이진 트리를 확장해서, 더 많은 수의 자식을 가질 수 있게 일반화 시킨 것이 B-Tree

- 자식 수에 대한 일반화를 진행하면서, 하나의 레벨에 더 저장되는 것 뿐만 아니라 트리의 균형을 자동으로 맞춰주는 로직까지 갖추었다.
- 단순하고 효율적이며, 레벨로만 따지면 완전히 균형을 맞춘 트리다.
- 대량의 데이터를 처리해야 할 때, 검색 구조의 경우 하나의 노드에 많은 데이터를 가질 수 있다는 점은 상당히 큰 장점이다.
- 대량의 데이터는 메모리보다 블럭 단위로 입출력하는 하드디스크 or SSD에 저장해야하기 때문!

ex) 한 블럭이 1024 바이트면, 2바이트를 읽으나 1024바이트를 읽으나 똑같은 입출력 비용 발생. 따라서 하나의 노드를 모두 1024바이트로 꽉 채워서 조절할 수 있으면 입출력에 있어서 효율적인 구성을 갖출 수 있다.

→ B-Tree는 이러한 장점을 토대로 많은 데이터베이스 시스템의 인덱스 저장 방법으로 애용하고 있음

<br>

### 규칙

- 노드의 자료수가 N이면, 자식 수는 N+1이어야 한다.
- 각 노드의 자료는 정렬된 상태여야 한다.
- 루트 노드는 적어도 2개 이상의 자식을 가져야 한다.
- 루트 노드를 제외한 모든 노드는 적어도 M/2개의 자료를 가지고 있어야 한다.
- 외부 노드로 가는 경로의 길이는 모두 같다.
- 입력 자료는 중복 될 수 없다.

<br>

## B+ Tree

> 데이터의 빠른 접근을 위한 인덱스 역할만 하는 비단말 노드(not Leaf)가 추가로 있다.

> 기존의 B-Tree와 데이터의 연결리스트로 구현된 색인구조

- B-Tree의 변형 구조로, index 부분과 leaf 노드로 구성된 순차 데이터 부분으로 이루어진다.
- 인덱스 부분의 key 값은 leaf에 있는 key 값을 직접 찾아가는데 사용한다.

<br>

### 장점

- 블럭 사이즈를 더 많이 이용할 수 있다. (key 값에 대한 하드디스크 액세스 주소가 없기 때문)
- leaf 노드끼리 연결 리스트로 연결되어 있어서 범위 탐색에 매우 유리하다.

### 단점

- B-tree의 경우 최상 케이스에서는 루트에서 끝날 수 있지만, B+tree는 무조건 leaf 노드까지 내려가봐야 한다.

<br>

### B-Tree & B+ Tree 비교

B-tree는 각 노드에 데이터가 저장된다.
B+tree는 index 노드와 leaf 노드로 분리되어 저장된다.
또한, leaf 노드는 서로 연결되어 있어서 임의접근이나 순차접근 모두 성능이 우수하다.

B-tree는 각 노드에서 key와 data 모두 들어갈 수 있고, data는 disk block으로 포인터가 될 수 있다.
B+tree는 각 노드에서 key만 들어간다. 따라서 data는 모두 leaf 노드에만 존재한다.
B+tree는 add와 delete가 모두 leaf 노드에서만 이루어진다.
