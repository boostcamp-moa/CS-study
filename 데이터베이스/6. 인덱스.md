## 인덱스 (Index)

### 인덱스를 왜 사용해야 할까?

<img src="https://i.imgur.com/RFI4clw.png" />

`SCOUNTER` 테이블에서 `AIRPORT` Column에 있는 `LCY`라는 값을 조회한다고 하자.
조회를 위한 `SELECT`문은 테이블에 있는 모든 데이터를 조회한 후 최종적으로 `LCY`가 포함된 레코드를 반환하는 로직으로 작동할 것이다.

만약 데이터가 수십만 개가 들어있을 때 조회 기능이 자주 실행되는 서비스가 있다면, 조회 기능이 실행될 때마다 모든 데이터를 탐색하고 값을 반환해준다.
이렇게 되면 트래픽에 따라 성능이 저하될 수밖에 없다.

> 이러한 문제점을 방지하고자 `인덱스`를 활용한다.
> 자주 조회되는 Column에 대한 `Index Table`을 따로 만들어 `SELECT`문이 들어왔을 때 `Index Table`에 있는 값들로 결과 값을 조회한다. (Full Scan이 이루어지지 않음)

> 결과적으로 `Index`를 잘 사용한다면 `검색` 연산을 실행했을 때 성능을 드라마틱하게 올릴 수 있게 된다.

- 테이블의 Column을 `색인화`한다. (따로 파일을 저장)

  - (B+ Tree 구조로) 색인화 된 인덱스 파일 검색으로 검색 속도 향상

<br>

### 인덱스는 어떻게 동작하는가?

- 테이블을 생성할 때 특정 Column에 대한 인덱스를 주면 그 Column에 대한 `인덱스 테이블`이 생성된다.
- 위의 예시를 이어가면, `SCOUNTER TABLE` 생성 시 `AIRPORT` Column에 대한 `인덱스`를 주면 `AIRPORT` Column에 대한 `인덱스 테이블`이 생성된다.
- `SCOUNTER TABLE`에 `AIRPORT` Column에 대한 `WHERE`문이 포함된 쿼리가 나갈 때 `AIRPORT` 인덱스 테이블에 저장된 `key-value`값을 참조하고 `SCOUNTER TABLE`에서 결과 값을 반환해온다.

- 동작 순서

  - `인덱스 테이블`에서 `WHERE`에 포함된 값을 찾는다.
  - 해당 값의 `table_id [PK]`를 가져온다.
  - 가져온 `table_id [PK]` 값으로 원본 테이블에서 값을 조회해온다.

- DBMS는 `인덱스`를 다양한 알고리즘으로 관리하고 있는데, 일반적으로 사용되는 알고리즘은 `B+ Tree` 알고리즘이다.

#### B-Tree 인덱스 알고리즘 ([참고](https://matice.tistory.com/8))

- 개요

    <span>
        <img src="https://t1.daumcdn.net/cfile/tistory/13565B4D4E30BF1A28" width="300px" />
    </span>
    <span>
        <img src="https://t1.daumcdn.net/cfile/tistory/240CF04C5900B5221B" width="300px" />
    </span>
    
    - 편향 트리의 경우, 검색 시 순차 검색과 다를 바가 없는 O(n)의 시간복잡도를 가진다.
    - 하지만 균형이 갖춰진 트리의 경우, 검색 시 O(logn)의 시간 복잡도를 가진다.
    - B-Tree도 이러한 균형 트리의 일종이다.


- B-Tree의 성립 조건

  - 노드의 데이터 개수가 `n`개라면 자식 노드의 개수는 `n+1`개여야 한다.
  - 노드의 데이터는 반드시 정렬된 상태여야 한다.
  - 어떤 노드의 자식노드의 데이터들은 부모 노드 데이터를 기준으로 데이터보다 작은 값은 왼쪽 서브 트리에 큰값들은 오른쪽 서브 트리에 위치해야 한다.
  - 루트 노드가 자식이 있다면 2개 이상의 자식을 가져야 한다.
  - 루트 노드를 제외한 모든 노드는 적어도 `M/2`개의 데이터를 갖고 있어야 한다. (여기서 M은 차수이다.)
  - 리프 노드로 가는 경로의 길이는 모두 같아야 한다. 즉, 리프 노드는 모두 같은 레벨에 있어야 한다. (Balanced Tree 구조)
  - 입력 자료는 중복될 수 없다.

- B-Tree와 B+Tree의 차이점 ([참고1](https://m.blog.naver.com/PostView.nhn?blogId=ya3344&logNo=221395287263&proxyReferer=https:%2F%2Fwww.google.com%2F), [참고2](https://zorba91.tistory.com/293))
  - B-tree의 각 노드에서는 key 뿐만 아니라 data도 들어갈 수 있다. 여기서 data는 disk block으로의 포인터가 될 수 있다.
  - B+tree는 각 node에서는 key만 들어가야 한다. 그러므로 B+tree에서는 data는 오직 leaf에만 존재한다.
  - B+tree는 B-tree와는 달리 add, delete가 leaf에서만 이루어진다.
  - B+ tree는 leaf node 끼리 linked list로 연결되어 있다.

<img src="https://i.imgur.com/dLpOqeo.png" />

- B+Tree의 구성

  - 리프 노드: 실제 데이터가 저장되는 노드
  - 브랜치 노드: 리프 노드까지의 경로 역할을 하는 노드
  - 루트 노드: 경로의 출발점 노드

- B+Tree는 리프 노드에 이르기까지 자식 노드에 대한 포인터가 저장되어 있다.
- B+Tree는 (리프 노드를 제외한) 각 node에서는 key만 들어가야 한다. 그러므로 B+Tree에서 data는 오직 리프 노드에만 존재한다.
- 탐색에 있어 루트 노드에서 어떤 리프 노드에 이르는 한 개의 경로만 검색하면 되기 때문에 매우 효율적이다.

<br>

### 인덱스의 종류 ([참고](https://12bme.tistory.com/149?category=682920))

> 인덱스는 기존 DB의 테이블과 다르게 데이터 중복성을 가질 수 있다.
> 그래서 다양한 종류의 인덱스 형태가 존재하는데, 인덱스 종류는 사용하는 목적에 따라 적절하게 사용하는 것이 좋다.

- 키에 따른 인덱스
  - 기본 인덱스 (Primary Index) : 기본키를 포함하는 인덱스(키의 순서가 레코드의 순서를 결정 지음)
  - 보조 인덱스 (Secondary Index) : 기본 인덱스 이외의 인덱스(키의 순서가 레코드의 순서를 의미하지는 않음)
- 파일 조직에 따른 인덱스
  - 집중 인덱스 (Clustered Index) : 데이터 레코드의 물리적 순서가 그 파일에 대한 인덱스 엔트리 순서와 유사하게 유지되도록 구성된 인덱스
  - 비집중 인덱스 (Unclustered Index) : 집중 형태가 아닌 인덱스
- 데이터 범위에 따른 인덱스
  - 밀집 인덱스 (Dense Index) : 데이터 레코드 각각에 대해 하나의 인덱스 엔트리가 만들어진 인덱스
  - 희소 인덱스 (Sparse Index) : 레코드 그룹 또는 데이터 블록에 대해 하나의 엔트리가 만들어지는 인덱스

<br>

### 언제 인덱스를 사용해야 할까? ([예시](https://itholic.github.io/database-index/))

- 인덱스의 특징을 먼저 살펴보면 `인덱스 테이블`과 `정렬`이 있다.

  - 인덱스 테이블
    - 인덱스는 하나의 테이블을 생성해 값을 지정해놓고 사용한다.
    - 그래서 다른 테이블에 의존적인 새로운 (인덱스) 테이블이 생성된다는 점에서 무분별한 인덱스 생성은 오히려 성능 저하를 초래한다.
  - 정렬
    - 인덱스 테이블은 `이진트리 검색`을 사용하기 때문에 기본적으로 정렬되어 있다.
    - 그래서 만약 인덱스 테이블이 참조하는 테이블에서 `삽입`, `수정`, `삭제`가 자주 일어난다면 인덱스 테이블에서는 데이터를 정렬하면서 `삽입`, `수정`, `삭제`가 이루어지기 때문에 전체적인 성능 저하를 초래한다.

- 인덱스를 사용하면 좋은 경우
  - `WHERE`절에서 자주 사용되는 Column
  - 외래키가 사용되는 Column
  - `JOIN`에 자주 사용되는 Column
- 인덱스 사용을 피해야 하는 경우
  - 데이터 중복도가 높은 Column (ex - 성별, 타입이 별로 없거나 적은 경우)
  - DML(`INSERT`, `DELETE`, `UPDATE`)이 자주 일어나는 Column

<br>

### DML이 일어났을 때의 상황

- `INSERT`

  - 인덱스의 Block(노드)들이 하나에서 두개로 나누어지는 현상인 `index split`가 발생할 수 있다.
  - 기존 Block에 여유가 없을 때, 새로운 데이터가 입력된다.
  - 새로운 Block을 할당 받은 후, Key를 옮기는 작업을 수행 (**많은 양의 Redo 유발**)
  - `index split` 작업동안, 해당 Block의 Key 값에 대해서 DML이 블로킹 된다. (**대기 이벤트 발생**)

- `DELETE`
  - 테이블과 인덱스 상황 비교
    - 테이블에서 데이터가 `DELETE`되는 경우: 데이터가 지워지고, 다른 데이터가 그 공간을 사용 가능하다.
    - 인덱스에서 데이터가 `DELETE`되는 경우: 데이터가 지워지지 않고, `사용 안 됨` 표시만 해둔다. (`테이블의 데이터 수`와 `인덱스의 데이터 수`가 다를 수 있다.)
  - 따라서 인덱스를 사용하더라도 수행속도를 기대하기 힘들다.
- `UPDATE`
  - 인덱스에는 `UPDATE` 개념이 없다.
  - 테이블에서 `UPDATE`가 발생하면 인덱스에서는 `DELETE`가 발생한 후, 새로운 작업의 `INSERT` 작업이 발생한다. (2배의 작업이 소요된다. => 다른 DML보다 더 큰 부하를 주게 된다.)

<br>

### 장점

- **데이터 검색속도가 향상된다.**
- **시스템 부하가 줄어들고 시스템의 전체 성능이 높아진다.**
- 데이터 테이블을 Full Scan하지 않고 더 빠르게 데이터에 접근할 수 있게 해준다.
- 즉, `SELECT`절의 속도가 빨라진다.

### 단점

- 인덱스 테이블을 위한 공간이 필요하기 때문에 필요없는 인덱스가 많아지면 차지하는 공간이 많아져서 Full Scan보다 속도가 느려질 수 있다.
- 인덱스 된 Field에서 데이터를 업데이트하거나, Record를 추가 또는 삭제 시 성능이 떨어진다.
- 데이터 변경 작업(DML)이 자주 일어나는 경우, 인덱스를 재작성해야 하므로, 성능이 저하된다.

<br>
<br>

### reference

- https://brunch.co.kr/@skeks463/25 [DataBase] DB 성능을 위한 Index
- https://lalwr.blogspot.com/2016/02/db-index.html DB Index 란?
