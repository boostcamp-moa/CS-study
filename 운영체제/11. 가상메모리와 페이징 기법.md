# 페이징과 세그먼테이션

## 메모리 관리 기법의 필요성

메모리의 크기는 컴퓨터마다 다른데 운영체제가 물리 메모리의 크기에만 의존한다면 `2GB`의 메모리에서 동작하는 프로그램이 `1GB`의 메모리에서는 동작하지 않을 수 있다.

그렇기 때문에 프로그래머 또한 메모리 크기에 맞는 응용 프로그램만 개발해야 하는데, 실제로 메모리 크기를 고려하여 프로그래밍하기란 어렵다.

따라서 메모리의 용량은 한정적이므로 여러 응용 프로그램의 사용을 위해 효율적인 메모리 관리 기법이 필요하다.

<br>

## 가상 메모리의 크기와 주소

> 현대 메모리 관리의 가장 큰 특징은 물리 메모리의 크기와 프로세스가 올라갈 메모리의 위치를 신경 쓰지 않고 프로그래밍하도록 지원한다는 것이다.
> 이러한 메모리 시스템을 `가상 메모리`라고 부른다.

가상 메모리는 물리 메모리의 크기와 상관없이 프로세스에 커다란 메모리 공간을 제공하는 기술이다.
프로세스는 운영체제가 어디에 있는지, 물리 메모리의 크기가 어느 정도인지 신경 쓰지 않고 메모리를 마음대로 사용할 수 있다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F99476C435EEDDF501FBE06)

가상 메모리는 크게 `프로세스가 바라보는 메모리 영역`과 `메모리 관리자가 바라보는 메모리 영역`으로 나뉜다.

이론적으로 가상 메모리는 무한대의 크기를 가질 수 있다.
그러나 실제로는 가상 메모리에서 메모리 관리자가 사용할 수 있는 메모리의 전체 크기는 `물리 메모리(실제 메모리)`와 `스왑 영역`을 합한 크기이다.

따라서 가상 메모리 시스템에서 메모리 관리자는 물리 메모리와 스왑 영역을 합쳐서 프로세스가 사용하는 가상 주소를 실제 메모리의 물리 주소로 변환한다.
이러한 작업을 `동적 주소 변환 (DAT)`이라고 한다.

동적 주소 변환을 거치면 프로세스가 아무 제약 없이 사용자의 데이터를 물리 메모리에 배치할 수 있다.
이 과정에서 메모리 관리자는 `물레 메모리를 어떤 방법으로 나눌지`, `사용자 프로세스를 어디에 배치할지`, `부족한 메모리를 어떻게 처리할지` 등의 복잡한 문제를 처리한다.

<br>

## 가상 메모리의 메모리 분할 방식

- `가변 분할 방식`을 이용한 `세그먼테이션`과 `고정 분할 방식`을 이용한 `페이징 기법`이 있다.
- 기본적으로 페이징 기법을 사용하나 페이지 테이블 관리가 어렵다는 문제가 있다.
- 세그먼테이션 기법은 외부 단편화 등의 문제가 있다.
- 따라서, 가상 메모리 시스템에서는 두 기법의 단점을 보완한 세그먼테이션-페이징 혼용 기법을 주로 사용한다.

<br>

### 가상 메모리와 물리 메모리 비교

![](https://i.imgur.com/cMnmR77.png)

<br>

## 메모리 매핑 테이블

> 가상 메모리 시스템에서 가상 주소는 실제로 물리 주소나 스왑 영역 중 한 곳에 위치한다.
> 메모리 관리자는 가상 주소와 물리 주소를 일대일 매핑 테이블로 관리한다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F994E6B435EEDE059221134)

`페이징 기법`에서 사용하는 매핑 테이블은 `페이지 매핑 테이블` 또는 `페이지 테이블`이라고 부른다.
`세그먼테이션 기법`에서 사용하는 매핑 테이블은 `세그먼테이션 매핑 테이블` 또는 `세그먼테이션 테이블`이라고 부른다.

<br>

## 페이징 기법

> 고정 분할 방식으로 메모리를 분할하여 관리하는 기법이다.

<br>

### 페이징 기법의 구현

페이징 기법은 고정 분할 방식 기반이기 때문에 물리 주소 공간을 같은 크기로 나누어 사용한다.

<br>

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F997D3A495EEDE12421214B)

- 가상 주소는 프로세스 입장에서 바라본 메모리 공간으로 항상 0번지부터 시작한다.
- 가상 주소의 분할된 각 영역은 `페이지`라고 부르며 번호(0, 1, 2, ..)를 매겨 관리한다.
- 물리 메모리의 각 영역은 가상 주소의 페이지와 구분하기 위해 `프레임`이라고 부르며 번호를 매겨 관리한다.
- 각각의 한 줄은 `페이지 테이블 엔트리(PTE)`라고 부른다.
- 페이지와 프레임의 크기는 같기 때문에 페이지는 어떤 프레임에도 배치될 수 있다.
- 페이지 테이블은 어떤 페이지가 어떤 프레임에 있는지에 대한 연결 정보를 가지고 있다.
- 페이지 테이블에 `invalid`는 해당 페이지가 `스왑 영역`에 있다는 것을 의미한다.
- 페이지 테이블에 페이지 번호가 `0`부터 순서대로 정리되어 있기 때문에 `페이지 테이블 엔트리`는 `프레임 번호`만 갖게 된다.

<br>

### 페이징 기법의 주소 변환

- 가상 주소 공간과 물리 주소 공간이 똑같이 10B로 나누어져 있고, 한 페이지 또는 한 프레임은 총 10개의 주소를 가진다고 가정
- 페이지 0에는 0 ~ 9번지의 10개 주소가, 페이지 1에는 10 ~ 19번지의 10개 주소가 있는 것이다.

<br>

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F99C9B7375EEDE1B2242C83)

- 프로세스가 30번지의 내용을 읽으려고 할 때 주소 변환 과정

1. 가상 주소 30번지가 어느 페이지에 있는지 찾는다. (페이지 3의 0번째 위치)
2. 페이지 테이블의 페이지 3으로 가서 해당 페이지가 프레임 1에 있다는 것을 알아낸다.
3. 최종적으로 물리 메모리 프레임 1의 0번째 위치에 접근한다. (이 주소가 가상 주소 30번지의 물리 주소이다.)

<br>

- 프로세스가 18번지에 값을 저장하려고 할 때 주소 변환 과정

1. 가상 주소 18번지가 어느 페이지에 있는지 찾는다. (페이지 1의 8번째 위치)
2. 페이지 테이블의 페이지 1로 가서 해당 페이지가 프레임 3에 있다는 것을 알아낸다.
3. 프로세스가 저장하려는 값을 프레임 3의 8번 위치에 저장한다.

<br>

### 정형화된 주소 변환

- 페이징 기법에서는 가상 주소를 `VA=<P, D>`로 표현
  - `VA` : 가상 주소(Virtual Address)
  - `P` : 페이지(Page)
  - `D` : 페이지의 처음 위치에서 해당 주소까지의 거리(Distance)
- 페이징 기법에서의 주소 변환은 가상 주소 `VA=<P, D>`를 물리 주소 `PA=<F, D>`로 변환하는 것
  - `PA` : 물리 메모리의 주소를 가리키는 용어로 물리 주소 또는 실제 주소
  - `F` : 프레임(Frame)
  - `D` : 프레임의 처음 위치에서 해당 주소까지의 거리(Distance)

<br>

- 페이징 기법의 주소 변환 과정
  - `VA=<P, D>` → `PA=<F, D>`
  - 페이지 테이블을 사용하여 `P`는 `F`로 바꾸고 `D`는 변경 없이 그대로 사용한다.
  - `D`를 변경하지 않는 이유는 페이지와 프레임의 크기를 똑같이 나누었기 때문이다.

<br>

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F9911EC345EEDE2AA27CF79)

<br>

### 페이지의 크기가 다양할 경우 가상 주소를 `<P, D>`로 변환하는 공식

`P`=나눗셈(가상 주소/한 페이지의 크기)의 몫
`D`=나눗셈(가상 주소/한 페이지의 크기)의 나머지

- `한 페이지의 크기가 10B`인 가상 메모리 시스템에서 `가상 주소 32번지`인 경우

  - P=3(32/10의 몫)
  - D=2(32/10의 나머지)

- `한 페이지의 크기가 512B`인 시스템에서 `가상 주소 2049번지`인 경우
  - P=4(2049/512의 몫)
  - D=1(2049/512의 나머지)

<br>

### 16bit CPU의 주소 변환 예시

16bit CPU의 컴퓨터에서 한 페이지의 크기가 2<sup>10</sup>B라고 가정

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F992AF4345EEDE3A7275312)

16bit CPU의 컴퓨터에서 한 프로세스가 사용할 수 있는 가상 메모리의 크기는 2<sup>16</sup>(65536)B이다.
사용자는 0번지부터 65535번지까지 가상 주소 공간을 사용할 수 있는 것이다.
한 페이지의 크기가 2<sup>10</sup>B이기 때문에 가상 주소로 사용할 수 있는 16bit 중에서 6bit는 페이지 번호로, 10bit는 페이지의 처음 위치에서 해당 주소까지의 거리로 사용한다.

<br>

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F992AF6345EEDE3A727B315)

<br>

전체 페이지의 수는 2<sup>6</sup>, 즉 64개이고 페이지는 0번부터 63번까지 존재한다.

- 물리 주소도 가상 주소와 같이 2<sup>10</sup>B로 나뉜다.
- 프레임은 0부터 31까지만 있다고 가정한다.
- 페이지 테이블은 페이지 테이블 엔트리가 0~63으로 총 64개이다.(페이지 테이블의 크기는 물리 주소의 크기가 아니라 프로세스의 크기에 비례)

<br>

- 프로세스가 `980번지`에 저장된 데이터를 요청했을 때 동적 주소 변환
  1. 가상 주소 `980번지`의 페이지 P, 거리 D를 구한다.
     - P=0(980/1024의 몫) D=980(980/1024의 나머지) → VA=<0, 980>
  2. 페이지 테이블로 가서 페이지 `0`이 프레임 `2`에 저장되어 있다는 것을 확인한다.
  3. 물리 메모리의 프레임 `2`에서 시작 지점으로부터 `980번지` 떨어진 곳에 접근하여 데이터를 가져온다.

<br>

## 페이지 테이블 관리

> 페이지 테이블 관리가 복잡한 이유는 시스템에 여러 개의 프로세스가 존재하고 프로세스마다 페이지 테이블이 하나씩 있기 때문이다.

다수의 프로세스가 있는 페이징 시스템

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F99E28D455EEDE41A20BF2F)

프로세스 A, B, C가 하나의 물리 메모리를 사용하고 있다.
프로세스는 메모리에 올라와야 실행 가능하므로 모든 프로세스의 일부 페이지가 물리 메모리의 프레임에 올라와 있고, 어떤 페이지가 어떤 프레임에 있는지 관리하기 위해 프로세스마다 페이지 테이블을 운영 중이다.

> 결과적으로 전체 페이지 테이블의 크기는 프로세스의 수에 비례해서 커진다.
> 여기서 문제는 페이지 테이블의 크기가 작지 않다는 것이다.
> 따라서 `페이지 테이블의 크기를 적정하게 유지하는 것`이 페이지 테이블 관리의 핵심이다.

<br>

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F99F183435EEDE46914CA99)

<br>

페이지 테이블의 수가 늘어나거나 페이지 테이블의 크기가 늘어나면 운영체제 영역이 늘어나 그만큼 사용자 영역이 줄어들게 된다.
물리 메모리의 크기가 작을 때는 프로세스만 스왑 영역으로 옮겨지는 것이 아니라 페이지 테이블의 일부도 스왑 영역으로 옮겨진다.

페이지 테이블에 빠르게 접근하기 위해 `레지스터`가 존재한다.
각 프로세스가 메모리에 접근하려고 할 때 메모리 관리자는 페이지 테이블의 위치를 재빨리 파악해야 한다.

> 그래서 각 페이지 테이블의 시작 주소를 `페이지 테이블 기준 레지스터(PTBR)`에 보관한다.
> `PTBR`은 각 프로세스의 PCB에 저장되는 데이터로, 물리 메모리 내에 페이지 테이블의 시작 주소를 가지고 있다.

<br>
<br>

### reference

- https://starrykss.tistory.com/966?category=790355 가상 메모리
- https://starrykss.tistory.com/967?category=790355 페이징 기법
