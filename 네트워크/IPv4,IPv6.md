## IPv6의 등장 배경

### 주소 공간 부족

IPv4는 중간중간에 Private용 등으로 예약된 주소영역과 연구용으로 사용되는 E 클래스 영역을 빼면 약 2억 5천만개 정도 사용할 수 있다.

많아보일 수도 있지만 IP 주소를 사용하는 장비들이 엄청난 속도로 증가하고 있기 때문에 사용할 수 있는 주소가 대부분 고갈된 상태이다.

이에 대한 해결방안으로 NAT, 서브넷 마스크, DHCP 등이 있지만 말 그대로 주소가 부족해서 나온 해결책 중 하나이고 근본적인 원인을 해결하지는 못한다. 

오히려 주소관리와 네트워크가 더 복잡해지는 단점이 있기도 하다.

### 그 외

- IPv4가 가지고 있는 복잡한 헤더  

- 효율적이지 못했던 보안 기능

## IPv6 특징 (IPv4와의 차이점 위주로)

위에서 언급한 IPv4의 한계 및 문제점들을 개선하기 위해 기존 IPv4를 대체하면서도 훨씬 개선된 새로운 IP 방식이 필요하게 되었는데 IPv6가 바로 그 방식이다.

### 주소 공간

앞에서 언급 했듯이 32비트 주소 체계를 사용하는 IPv4에서는 실질적으로 사용 가능한 주소의 개수는 약 2억 5천만개이다.

IPv6는 128비트 주소 체계를 가진다.  
ex) 2dfc:0:0:0:0217:cbff:fe8c:0

2^128 = 340282366920938463463374607431768211456

지구에 존재하는 사람 1명당 10^28를 나눌 수 있을 정도니 주소 부족에 대한 걱정은 안해도 된다. 

가용 가능한 주소 공간이 넓어짐에 따라 다음과 같은 이점이 있다.

- 진정한 End-to-End Reachability 실현

   사용 가능한 주소가 엄청 많기 때문에 전 세계의 네트워크 어디에서나 주소를 변경하지 않고, 즉 고유의 주소를 가지고 접속이 가능하다. (NAT 같은거 필요 없음)
 
- 주소의 계층화를 통한 간편한 주소 관리

  - 처음 16bit: 상용 주소 구분
  - 17~23bit: 대륙 구분
  - 23~32bit: 대륙에 있는 ISP 구분
  - 32~48bit: 하나의 사이트 (회사나 기관, 학교) 구분
  - 48~64비트: 각 LAN을 구분
  
 - aggregation
  
    여러 개의 트래픽을 하나로 묶어주는 것이 가능해진다. 같은방향으로 가는 트래픽을 구분해서 하나로 묶어 보내게 되면 네트워크의 트래픽을 훨씬 줄일 수 있다.
  
    예를 들어 미국에서 누군가 한국 주소를 번지수까지 적어서 편지를 보낼 때 주소를 다 확인해 보는 게 아니고 한국으로 가는 건 모두 모아서 한국의 대표 우체국(라우터)로 보낸다.
  
### Stateless Auto Configuration

`Stateful Auto Configuration`이란 어떤 state를 계속 유지하면서 자동 구성을 지원해준다는 말이다. 예를들면 DHCP가 특정 서버에서 테이블을 관리하면서 IP 주소를 관리하는 방식이다.

IPv4 에서는 `Stateful Auto Configuration`은 지원이 됐다.

그러나 `Stateless Auto Configuration`은 IPv6 에서만 지원이 된다. 
즉, 특정 서버가 없이도 라우터 등에서 자동으로 호스트의 IP를 구성이 가능하다.

<img src="https://images.velog.io/images/mu1616/post/99240518-85ee-472b-876d-bfa9a18604a3/image.png" width="600" />

PC가 새로 네트워크에 접속했을 때 이 PC가 가지고 있는 48비트의 MAC address를 가지고 64비트 주소로 만든다. 그 다음에 자기가 속한 네트워크에 있는 라우터에게 앞에있는 64비트(Prefix) 를 전송받아 총 128비트짜리 IPv6 주소를 만들어낸다.

따라서 호스트 입장에서는 따로 해줄게 없다. 그냥 연결만 하면 바로 네트워크와 연결될 수 있다.

(IPv6 에 `Stateful Auto Configuration`이 없는 것은 아님. 호스트에 대한 구체적인 세팅이 필요한경우 `Stateful Auto Configuration` 방식을 사용함)

### 브로드 캐스트 대신 멀티캐스트

IPv4 에서 골칫거리 중 하나는 `브로드캐스트`였다.
무조건 모든 곳으로 원하든 원치 않던 전송해버리기 때문에 많은 양의 네트워크 트래픽을 잡아 먹는다.

하지만, ARP 같은 곳에도 쓰이기 때문에 필요악 같은 존재였다.

IPv6에서는 `브로드캐스트` 대신 `멀티캐스트`가 그 역할을 한다.
IPv4에서도 `멀티캐스트`가 존재하지만 IPv6에서는 그 기능이 훨씬 강화되었다.

<img src="https://images.velog.io/images/mu1616/post/f04dc83d-5401-441a-a6d1-cc6ac6f57d3c/image.png" width="600" />

IPv6의 `멀티캐스트`는 4비트의 Scope ID라는 것을 사용한다.  
이 Scope ID는 `멀티캐스트`의 전송영역을 지정해줄 수 있는 역할을 한다. 따라서 같은 `멀티캐스트`라도 IPv6 에서는 어디까지 받을 수 있게 전송할 것인가를 정해줄 수 있다.


### 간단해진 헤더 정보

IPv4와 비교하여 IPv6의 헤더 정보는 많이 간단해졌다.
기존에는 Source address 와 Destination address가 32비트면 됐지만 IPv6에서는 그 4배인 128비트가 되니까 헤더 정보를 효과적으로 줄일 필요가 있었다.

또한 IPv4에서 만들어 사용해보니까 '이런 건 필요 없겠구나..' 하는 헤더정보를 과감하게 제거하였다.

<img src="https://images.velog.io/images/mu1616/post/8ccdddab-79a4-40b2-97a8-e850540cd9f4/image.png" width="600" />

헤더 정보를 많이 간소화했기 때문에 패킷 처리가 빨라지고 라우팅 성능이 향상 되었지만 주소 길이가 4배로 늘어나 주소 확인에는 다소 시간이 걸린다는 단점도 있다.

### IPSec 지원 (보안 강화)

IPSec은 Host-to-Host와 Network-to-Network 간의 데이터 흐름을 암호화 시키는 프로토콜 이다.

IPv4는 IPSec이 옵션으로 지원된다.
하지만 IPv6는 IPSec이 디폴트이고 IPSec을 지원하는 확장 헤더가 존재하기 때문에 IPSec을 쉽게 적용할 수 있다.

<img src="https://images.velog.io/images/mu1616/post/d51e2474-67e8-4f50-819b-06fcf8c08a87/image.png" width="600" />

레퍼런스

https://pandaria.tistory.com/76?category=519643

https://yjshin.tistory.com/entry/IPv4%EC%99%80-IPv6%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90

https://xn--3e0bx5euxnjje69i70af08bea817g.xn--3e0b707e/jsp/resources/vsix/structureExpand.jsp

후니의 쉽게 쓴 시스코 네트워킹
