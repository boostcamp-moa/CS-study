레퍼런스 :

https://velog.io/@conatuseus/2019-09-10-2009-%EC%9E%91%EC%84%B1%EB%90%A8-xsk0ds2eqf#12-%EA%B3%84%EC%B8%B5%EC%9C%BC%EB%A1%9C-%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94-tcpip (한국어 블로그)

https://www.cloudflare.com/ko-kr/learning/network-layer/what-is-routing/ (클라우드 플레어 라우팅 설명)

https://hackmd.io/tPsCkDPzTRO9qvEfQvCOTA (TCP/UDP)

http://wildpup.cafe24.com/archives/469 (Sliding Window)

## 네트워크 계층 (3계층)

> 시스템들 간의 네트워크 연결을 관리하고, 패킷을 목적지까지 가장 빠른 길로 전송하는 역할을 수행한다. IP, ICMP, IGMP, X.25, ARP, OSPF 같은 프로토콜을 사용한다.

### 라우팅

> 출발지에서 목적지 까지의 경로 설정

![](https://i.imgur.com/T4HoYNZ.png)

컴퓨터 A에서 B로 데이터 패킷을 전송해야할때 위의 그림과 같은 상황에서는

1-3-5 을 통해서 B로 가는 방법과, 2-4 을 통해서 B로 가는 방법이 존재한다.

언뜻 보아선 2-4을 통해서 가는 방법이 가장 빠른 방법 같아 보이지만

2-4 네트워크 사이엔 통신을 지체하는 어떤 버그가 있어 1-3-5을 통해서 가는 것이 더 빠르다.

라우터는 이런 조건들을 고려해서 가장 빠른 최적의 경로를 찾는 역할을 수행한다.

### 라우팅 테이블

![](https://i.imgur.com/q4FUikj.png)

위 그림과 같이 패킷의 목적지와 가야할 다음 위치를 적어놓은 테이블을 라우팅 테이블이라고 한다.

![](https://i.imgur.com/Q4k1E7H.png)
라우터에 만약 패킷이 들어오면 패킷 헤더의 목적지를 확인한후
라우팅 테이블의 정보를 바탕으로 다음 패킷을 어느 곳을 보내는지 결정합니다.

라우팅 테이블을 정의하는 방법은 크게 정적 라우팅 테이블과 동적 라우팅 테이블 2가지가 존재한다.

정적 라우팅 테이블은 관리자가 손수 라우팅 테이블을 세팅하고 그 테이블을 사용하는 방법이고

동적 라우팅 테이블은 테이블이 자동으로 업데이트 되는 방법을 의미한다.

OSPF (Open Shortest Path First), RIP 프로토콜이 존재한다.

### OSPF

### 포워딩

> 입력 링크로 들어온 패킷을 출력 링크로 전달하는 행위

## 전송 계층 (4계층)

> 네트워크로 접속되어 있는 2대의 컴퓨터 사이의 흐름을 제공한다.
> 전송 연결 설정, 데이터 전소으 연결 해제 기능을 수행한다.

### TCP

> 양방향 데이터 전송 방식, 신뢰성이 높지만 속도가 느리다.

![](https://i.imgur.com/9mkkDYb.png)

#### 3-way Hand Shaking

1. 클라이언트가 SYN을 보내고 대기한다.
2. 서버는 SYNC을 받고 SYN와 ACK을 Client에게 보낸다.
3. 클라이언트는 SYNC을 받고 서버에게 다시 ACK을 보낸다.

이 일련의 과정이 3번 일어나기 때문에 3-way handShaking이라고 부른다.

#### 4-way Hand Shaking

1. 클라이언트가 서버에게 FIN을 보내고 대기한다.
2. 서버는 FIN을 받은 후 클라이언트에게 ACK을 보내고 클라이언트와의 연결을 종료한다.
3. 성공적으로 종료되면 FIN을 보낸다.
4. 클라이언트는 마지막으로 접속이 종료 되었는지 확인하기 위해 ACK을 보낸다.

#### TCP Flow Control

네트워크의 처리 속도를 조절하는 방법

- Stop and Wait 방식

![](https://i.imgur.com/bp6pZg3.png)

프레임을 하나 보내고, ACK가 올 때 까지 기다리는 방법, 한번에 하나씩 주고 받는 방식, 구현 방식이 단순하지만 전송 효율이 떨어진다.

- Sliding-Window 방식

![](https://i.imgur.com/sMTm44N.jpg)

전송측에서 윈도우라는 버퍼를 잡고 해당 버퍼에서 순차적으로 프레임을 전송하는 방법

위 그림에서 버퍼는 0~6 사이이고 순차적으로 프레임을 전송한다.

수신 측에서 만약 0,1 버퍼를 받아 Ack을 날리게 되면

![](https://i.imgur.com/mynDZsL.jpg)

전송 측에선 그만큼 윈도우를 밀어내 다음 프레임을 전송하는 방법이다.

만약 수신 측에 보낸 데이터에 오류가 있어 NAK을 받게 되면

GobackN, Selective Reject 방법에 따라 다르게 처리된다.

#### Go-Back-n

현재 윈도우의 0~6까지 데이터를 모두 보내었는데

수신측에서 2번 프레임에서 오류가 발생한것을 발견하고 NAK2을 보내게 되면

송신 측은 프레임을 2번 프레임부터 " 전부 " 재전송하게 된다.

만약 0~6까지 데이터를 모두 보내었는데 2번 프레임의 ACK가 특정 시간이 지날때 까지 오지 않으면

송신 측은 2번 프레임이 전송되지 않았다고 판단하고 모두 재전송하게 된다.

#### Selective Reject

(이제부터 줄여서 SR이라고 하겠다.)

SR 방법은 GBN 방법과 다르게 분실된 프레임부터 "모두" 재전송 하는것이 아닌 분실된 프레임만 재전송한다.

수신측에서 별도의 버퍼를 두어 데이터를 정렬하며 유실된 데이터를 확인해야 하기 때문에 구조가 복잡하다.

최근엔 데이터 유실율이 거의 없기 때문에 GBN을 선호한다고 한다.

### UDP

> 단방향 데이터 전송 방식, 신뢰성이 낮지만 속도는 빠르다.

![](https://i.imgur.com/rcJHmp4.png)

최소한의 오류만 검출하고 양방향이 아닌 단방향 이기 때문에 속도가 빠른 Streaming 서비스에 자주 사용된다.

![](https://i.imgur.com/WZ2WYAz.png)

HTTP3 부터는 TCP가 아닌 UDP 프로토콜을 사용한다.

https://evan-moon.github.io/2019/10/08/what-is-http3/
